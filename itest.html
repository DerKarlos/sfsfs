<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Babylon-Test: Immerse</title>

    <style>
        html, body    { width: 100%; height: 100%; overflow: hidden; margin: 0; padding: 0; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>

    <script src="https://preview.babylonjs.com/babylon.max.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js'></script>

    <!--
    -->

</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <script type='module'>

    import { HeadMountedDisplay  } from './src/hmd.js';

    //import { DefaultImmersiveExperience } from './immersive.js';
    // Ã„nderung in der js kommen beim iPhone nicht durch !!!
    // Daher testen besser hier inline <====


////////////////////////////////////////////////////////////////////////////////////////////////////

export class DefaultImmersiveExperience {   // (create)DefaultImmersiveExperienceAsync


    constructor(scene) {
        this._scene  = scene;
        this.camera  =
        this.deviceOrientationCamera = scene.cameras[0];
        this.cameraChangedCallback = undefined;
        return this;
    }


    onCameraChanged(callback) {
        this.cameraChangedCallback = callback;
    }


    async init() {

        this.webvrOk = (navigator.getVRDisplays !== undefined) ? 1 : 0;
        this.webxrOk = (navigator.xr            !== undefined) ? 1 : 0;
        console.log("WebVR", this.webvrOk);
        console.log("WebXR", this.webxrOk);

        //        alert("VX: "+this.webvrOk+","+this.webxrOk)

        if(!this.webvrOk && !this.webxrOk) {
            console.log("No WebVR/XR, iPhone")
            this.vrHelper = this._scene.createDefaultVRExperience( {createDeviceOrientationCamera:false} );
            await this.vrHelper
            this.imCamera = this._scene.cameras[1]; // WHAT??? Not a solution!!! This does not work:   this.vrHelper.deviceOrientationCamera; // const???   webVRCamera    currentVRCamera  deviceOrientationCamera=mono  vrDeviceOrientationCamera=falback?
        } else {
            if(this.webxrOk) {
                console.log("WebXR ok, Quest")
                this.xrHelper = await this._scene.createDefaultXRExperienceAsync( { floorMeshes: [] } );
                this.imCamera = this.xrHelper.baseExperience.camera // Not a solution!!! This does not work:
            } else {
                console.log("Only WebVR, mac")
                this.polyfill = new WebXRPolyfill(); // now, navigator.xr should exist. Returns object with .nativeWebXR
                this.webxrOk = (navigator.xr !== undefined) ? 2 : -0;
                console.log("WebXR="+this.webxrOk)
                this.xrHelper = await this._scene.createDefaultXRExperienceAsync();
                await this.xrHelper;
                this.imCamera = this.xrHelper.baseExperience.camera

                this.immersiveOk = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync('immersive-vr');
                console.log("immersive",this.immersiveOk)
            }
        }

        if(this.xrHelper!==undefined)
        this.xrHelper.baseExperience.onStateChangedObservable.add( (state) => {
            switch(state) {
                case BABYLON.WebXRState.NOT_IN_XR: this.cameraChanged(this.deviceOrientationCamera, false); break;
                case BABYLON.WebXRState.IN_XR:     this.cameraChanged(this.imCamera               , true ); break;
            }
        });

        if( this.vrHelper!==undefined)
            this.vrHelper.onEnteringVRObservable.add(()=>{
                this.cameraChanged(this.imCamera, true);
            })

    }


    cameraChanged(camera,immersive) {
        this.camera = camera;
        if( this.cameraChangedCallback ) {
            this.cameraChangedCallback(camera,immersive)
        }
    }



    addFloorMesh(groundMesh) {
        if( this.xrHelper )
            this.xrHelper.teleportation.addFloorMesh(groundMesh);
        if( this.vrHelper )
            this.vrHelper.enableTeleportation({ floorMeshName: groundMesh.name });
    }


}

////////////////////////////////////////////////////////////////////////////////////////////////////


    /**/  // To see errors on touch devices, activate this Errorhandler producing Galert dialogs
    window.onerror = function(msg,url,line){ alert(msg+'\n'+url+'\nLine: '+line); return true; }
    /**/

    window.addEventListener('DOMContentLoaded', async function() {

        // get the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        var createScene = async function(){
            // create a basic BJS Scene object
            var scene = new BABYLON.Scene(engine);

            // Die "normale" Kamera macht man vor der Immersiven
            scene.createDefaultCameraOrLight(true, true, true) // auto view to existing objects !! Noch keine da!!

            var iex = new DefaultImmersiveExperience(scene);
            await iex.init();

            scene.hmd = new HeadMountedDisplay(iex.deviceOrientationCamera,scene,iex); // xrHelper.baseExperience.camera

            var fNEAR = 2;                          // to show the bike close by
            var fFAR  = 10*1000                     // to show the far away earth. Default: 10'000

            iex.camera.minZ     /= fNEAR
            iex.camera.maxZ     *= fFAR

            scene.hmd.out(["TEST START", "itest"],4000);

            var box = BABYLON.MeshBuilder.CreateBox("box", {});
            box.position.z = 5;
            var material = new BABYLON.StandardMaterial("mat", scene);
            if(iex.webxrOk) material.emissiveColor = new BABYLON.Color3(0, 1, 0); // green
            box.material = material;

            var environment = scene.createDefaultEnvironment({ enableGroundShadow: true });
            iex.addFloorMesh(environment.ground);
/**
            var environment = scene.createDefaultEnvironment({ enableGroundShadow: true });
            if( iex.xrHelper )
                iex.xrHelper.teleportation.addFloorMesh(environment.ground);
            if( iex.vrHelper )
                iex.vrHelper.enableTeleportation({ floorMeshName: environment.ground.name });
**/
            // return the created scene
            return scene;
        }

        // call the createScene function
        var scene = await createScene();

        var plus = 0
        // run the render loop
        engine.runRenderLoop(function(){
            plus++;
//            scene.hmd.out(["plus: "+plus])
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
    </script>
</body>
</html>
