<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Babylon-Test: Immerse</title>

    <style>
        html, body    { width: 100%; height: 100%; overflow: hidden; margin: 0; padding: 0; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; }
    </style>

    <script src="https://cdn.babylonjs.com/babylon.max.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js'></script>

    <!--
    -->

</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <script type='module'>
    import { HeadMountedDisplay  } from './src/hmd.js';

    //import { DefaultImmersiveExperience } from './immersive.js';
    // Ã„nderung in der js kommen beim iPhone nicht durch !!!
    // Daher testen besser hier inline <====

////////////////////////////////////////////////////////////////////////////////////////////////////

export class DefaultImmersiveExperience {   // (create)DefaultImmersiveExperienceAsync


    constructor(scene) {
        this._scene  = scene;
        this.camera  =
        this.deviceOrientationCamera = scene.cameras[0];
        return this;
    }


    async init() {

        this.webvrOk = (navigator.getVRDisplays !== undefined) ? 1 : 0;
        this.webxrOk = (navigator.xr            !== undefined) ? 1 : 0;
        console.log("WebVR", this.webvrOk)
        console.log("WebXR", this.webxrOk)

//        alert("VX: "+this.webvrOk+","+this.webxrOk)

        if(!this.webvrOk && !this.webxrOk) {
            console.log("No WebVR/XR, iPhone")
            this.vrHelper = this._scene.createDefaultVRExperience( {createDeviceOrientationCamera:false} );
            await this.vrHelper
            this.imCamera = this.vrHelper.webVRCamera; // const???
        } else {
            if(this.webxrOk) {
                console.log("WebXR ok, Quest")
                this.xrHelper = await this._scene.createDefaultXRExperienceAsync( { floorMeshes: [] } );
                this.imCamera = this.xrHelper.baseExperience.camera
            } else {
                console.log("Only WebVR, mac")
                this.polyfill = new WebXRPolyfill(); // now, navigator.xr should exist. Returns object with .nativeWebXR
                this.webxrOk = (navigator.xr !== undefined) ? 2 : -0;
                console.log("WebXR="+this.webxrOk)
                this.xrHelper = await this._scene.createDefaultXRExperienceAsync();
                await this.xrHelper;
                this.imCamera = this.xrHelper.baseExperience.camera

                this.immersiveOk = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync('immersive-vr');
                console.log("immersive",this.immersiveOk)
            }
        }


        if(this.xrHelper!==undefined)
        this.xrHelper.baseExperience.onStateChangedObservable.add((state) => {
            switch(state) {
                case BABYLON.WebXRState.NOT_IN_XR: this.camera = this.deviceOrientationCamera; break;
                case BABYLON.WebXRState.IN_XR:     this.camera = this.imCamera;                break;
            }
        });

    }


    async addFloor(meshName) {
        console.log(meshName);
        if(xrHelper)
            this.xrHelper.teleportation.addFloorMesh(meshName); // floorMeshName
    }


}

////////////////////////////////////////////////////////////////////////////////////////////////////


    /**/  // To see errors on touch devices, activate this Errorhandler producing Galert dialogs
    window.onerror = function(msg,url,line){ alert(msg+'\n'+url+'\nLine: '+line); return true; }
    /**/

    window.addEventListener('DOMContentLoaded', async function() {

        // get the canvas DOM element
        var canvas = document.getElementById('renderCanvas');

        // load the 3D engine
        var engine = new BABYLON.Engine(canvas, true);

        // createScene function that creates and return the scene
        var createScene = async function(){
            // create a basic BJS Scene object
            var scene = new BABYLON.Scene(engine);

            // Die "normale" Kamera macht man vor der Immersiven
            scene.createDefaultCameraOrLight(true, true, true) // auto view to existing objects !! Noch keine da!!

            var iex = new DefaultImmersiveExperience(scene);
            await iex.init();

            scene.hmd = new HeadMountedDisplay(iex.deviceOrientationCamera,scene); // xrHelper.baseExperience.camera

            if(iex.xrHelper)
            iex.xrHelper.baseExperience.onStateChangedObservable.add((state) => {
                switch(state) {
                    case BABYLON.WebXRState.NOT_IN_XR:
                    case BABYLON.WebXRState.IN_XR:     scene.hmd.setParent(iex.camera ); break;
                }
                scene.hmd.out(["xr StateChanged",""+state] );
            });

            var fNEAR = 2;                          // to show the bike close by
            var fFAR  = 10*1000                     // to show the far away earth. Default: 10'000

            iex.camera.minZ     /= fNEAR
            iex.camera.maxZ     *= fFAR

            scene.hmd.out(["TEST START", "itest"],4000);


            var box = BABYLON.MeshBuilder.CreateBox("box", {});
            box.position.z = 5;
            var material = new BABYLON.StandardMaterial("mat", scene);
            if(iex.webxrOk) material.emissiveColor = new BABYLON.Color3(0, 1, 0); // green
            box.material = material;

            var environment = scene.createDefaultEnvironment({ enableGroundShadow: true });


            // return the created scene
            return scene;
        }

        // call the createScene function
        var scene = await createScene();

        var plus = 0
        // run the render loop
        engine.runRenderLoop(function(){
            plus++;
            scene.hmd.out(["plus: "+plus])
            scene.render();
        });

        // the canvas/window resize event handler
        window.addEventListener('resize', function(){
            engine.resize();
        });
    });
    </script>
</body>
</html>
