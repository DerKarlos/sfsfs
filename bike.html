<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>Space Bike</title>
    <style>
    html, body { overflow:   hidden;    width: 100%;    height: 100%;     margin: 0;    padding: 0;    }
    #viewer    { touch-action: none;    width: 100%;    height: 100%;                            }
    </style>
</head>
<body>

    <canvas id='viewer' />
    <script src ='lib/babylon.max.js'> </script>
    <script src ='lib/babylonjs.loaders.min.js'> </script>
    <script type='module'>

    /**/
    // To see errors on touch devices, activate this Errorhandler producing Galert dialogs
    window.onerror = function(msg,url,line){
        alert(msg+'\n'+url+'\nLine: '+line)
        return true
    }
    /**/



    /*
        https://www.babylonjs-playground.com/#PYTAP9#2
    */

    function rad(degrees)    { return degrees * (Math.PI/180); }
    function grad(rad)       { return rad     / (Math.PI/180); }

    function setDeadZone(value) {
        const DEADZONE = 0.2;

        // If stick value is smaller than dead zone, give it a value of 0
        // Math.abs() makes it work regardless of positive or negative value
        if (Math.abs(value) < DEADZONE) {

            return value = 0;

        } else {
            // We are outside the dead zone: substract deadzoone
            value = value - Math.sign(value) * DEADZONE;

            // Normalize the values between 0 and 1
            value /= (1.0 - DEADZONE);

            return value;

        }
    }


    function loadGlb(name,scene,success) {

        BABYLON.Tools.corsbehavior = "anonymous";   // FileTools.CorsBehavior = “credentials”  /  "anonymous"   ??? videoTexture.video.crossOrigin = "anonymous";
        BABYLON.SceneLoader.ImportMesh('', 'ships/', name+'.glb', scene, // wheelchair aufgabe_orion radiatoren
            /* onSuccess: */ function (newMeshes) {
                // how do avoid to see the array for a moment???  It should also be noted that a mesh with a layerMask of 0, can never be seen by anyone. This might be good for hiding things.
                console.log("loaded: "+name);
                var glb = new BABYLON.Mesh(name, scene);
                for(var index in newMeshes) {
                    var mesh = newMeshes[index]; //console.log("o." + index + " = " + mesh);
                    glb.addChild(mesh);
                }
                if(success)
                    success(glb);
            }.bind(this),
            /* onProgress: */ function (event) {   console.log("model loaded: ", Math.floor(event.loaded/event.total*100)+"%") },
            /* onError:    */ function (event) {   console.log("onError:"+name,event) }
        );//ImportMesh

    }

    class Ramp { ////////////////////////////////////////////////// Ramp (helper CLASS) ////////////////////////////////////////////

        constructor(up,down,initValue) {
            if(!up)   up   = 1;
            if(!down) down = up;
            if(!initValue) initValue = 0;
            this.up     = up;
            this.down   = down;
            this.actual = initValue;
        }


        reset() {
            this.actual = 0
        }


        ramping(set,dt) {

            var delta = set-this.actual;
            var abs   = Math.abs( delta);
            var sign  = Math.sign(delta);
            var ramp  = (sign==Math.sign(this.actual)) ? this.up : this.down;
            if( abs   > ramp*dt)
                abs   = ramp*dt;
            delta     = abs * sign;

            this.actual += delta;
            return this.actual;
        }


    }//class ramp


    class Ramp3 {
        constructor() {
            this.x = new Ramp();
            this.y = new Ramp();
            this.z = new Ramp();
            this.actual = new BABYLON.Vector3();
        }

        ramping(x,y,z,dt) {
            this.actual.x = this.x.ramping(x, dt);
            this.actual.y = this.y.ramping(y, dt);
            this.actual.z = this.z.ramping(z, dt);
            return this.actual;
        }

        reset() {
            this.x.reset();
            this.y.reset();
            this.z.reset();
        }

    }


    class Control {

        constructor(engine, vrHelper){

            this.keyLeftRight  = 0;
            this.keyUpDown     = 0;
            this.keyPagePS     = 0; // Page Up/Down = Plus/Sharpe-Keys
            this.keyMPoint     = 0; //                Minus/Point-Keys
            this.joystick      = new BABYLON.Vector3();

            this.rampPosition  = new Ramp3();
            this.rampRotation  = new Ramp3();

            document.addEventListener("keydown", this.onKeyDown.bind(this), false);
            document.addEventListener("keyup",   this.onKeyUp.bind(this),   false);
            window.addEventListener(  "resize",  function(){ engine.resize(); }  );


            //// Oclus controls      https://playground.babylonjs.com/#0IBX3Y#1
            vrHelper.onControllerMeshLoaded.add((webVRController)=>{
                control.joystick.x = 0.1;
                // buttons
                webVRController.onBButtonStateChangedObservable.add((stateObject)=>{
                    // if(webVRController.hand ==='right') -- enable both controller       Y <=> B
                    this.resetPositionAndRotation();
                });

                webVRController.onAButtonStateChangedObservable.add((stateObject)=>{ //    X <=> A
                    if(stateObject.pressed === true){
                        this.stop = true;
                    } else {
                        this.stop = false;
                    }


                });

                webVRController.onPadStateChangedObservable.add((stateObject)=>{
                    //???
                });

                webVRController.onTriggerStateChangedObservable.add((stateObject)=>{
                    this.joystick.z = stateObject.value;
                });

                webVRController.onSecondaryTriggerStateChangedObservable.add((stateObject)=>{
                    this.joystick.z = -stateObject.value;
                });

                // joystick:
                webVRController.onPadValuesChangedObservable.add((stateObject)=>{
                    // if(webVRController.hand ==='right') -- enable both controller
                    {
                        control.joystick.x = stateObject.x;
                        control.joystick.y = stateObject.y;
                    }
                }); // onPadValuesChangedObservable

            });     // onControllerMeshLoaded


        }// constructor


        resetPositionAndRotation() {
            this.rampPosition.reset();
            this.rampRotation.reset();
            bike.resetPositionAndRotation();
        }


        onKeyDown(evt) {
            switch (evt.keyCode) {
                case  13: this.resetPositionAndRotation(); break; // return
                case  32: this.stop = true;                break; // space
                case  39: this.keyLeftRight = +1;          break; // right
                case  37: this.keyLeftRight = -1;          break; // left
                case  38: this.keyUpDown    = +1;          break; // up
                case  40: this.keyUpDown    = -1;          break; // down
                case 163: this.keyPagePS    = +1;          break; // +
                case 171: this.keyPagePS    = -1;          break; // #
                case 173: this.keyMPoint    = +1;          break; // -
                case 190: this.keyMPoint    = -1;          break; // .
                default: console.log("KEY: "+evt.keyCode);
            }
        }

        onKeyUp(evt) {
            switch (evt.keyCode) {
                case  32:           this.stop = false;      break;
                case  39: case  37: this.keyLeftRight =  0; break;
                case  38: case  40: this.keyUpDown    =  0; break;
                case 163: case 171: this.keyPagePS    =  0; break;
                case 173: case 190: this.keyMPoint    =  0; break;
            }
        }

        animate(dSec) {

            var accelInputX  = setDeadZone(this.joystick.x) * +1; // +/- 0.2 to 1.0  becomes  0.0 to 1.0
            var accelInputY  = setDeadZone(this.joystick.y) * -1;
            var accelInputZ  = setDeadZone(this.joystick.z) * +1;

            if(this.stop)
                this.stop = bike.stop(dSec);


            var accelerationPosition = this.rampPosition.ramping(
                0,                           // shift
                0,                           // rise
                +accelInputY+this.keyUpDown, // speed
                dSec);

            var accelerationRotation = this.rampRotation.ramping(
                -accelInputZ+this.keyPagePS,    // v^   roll  z
                +accelInputX+this.keyLeftRight, // <>   pitch x
                0           +this.keyMPoint,    // ()   yaw   y
                dSec);

            var matrix = bike.root.getWorldMatrix().getRotationMatrix();
            accelerationPosition = accelerationPosition.multiplyByFloats(1,1,5);
            accelerationPosition = BABYLON.Vector3.TransformCoordinates(accelerationPosition, matrix);  // applyEuler

            switch("mix") {

                case "fake":
                bike.setSpeed(        accelerationPosition.scaleInPlace(0.01),
                                      accelerationRotation.scaleInPlace(0.01)  );
                break;

                case "mix":
                bike.setAcceleratoin( accelerationPosition.scaleInPlace(0.001), 0 );
                bike.setSpeed( 0,     accelerationRotation.scaleInPlace(0.010)    );
                break;

                case "real":
                bike.setAcceleratoin( accelerationPosition.scaleInPlace(0.0010),
                                      accelerationRotation.scaleInPlace(0.0001)  );


                var limit = 0.01;
                var min = new BABYLON.Vector3(-limit,-limit,-limit);
                var max = new BABYLON.Vector3(+limit,+limit,+limit);
                bike.speedRotation = BABYLON.Vector3.Clamp(bike.speedRotation,min,max);
                break;

            }

        }

    }

    class Bike {

        constructor(scene) {

            //// Space Bike (root, body and camera position)
            this.root = new BABYLON.TransformNode("root", scene);
            this.resetPositionAndRotation();

            var body = BABYLON.MeshBuilder.CreateCylinder("body", {height: 3, diameterTop: 0.2, diameterBottom: 1, tessellation: 16}, scene);
            body.rotation.x = rad(90);
            body.parent     = this.root;
            body.position.z = +0.5;

            var handle = BABYLON.MeshBuilder.CreateCylinder("handle", {height: 1, diameterTop: 0.025, diameterBottom: 0.025, tessellation: 16}, scene);
            handle.rotation.z = rad(90);
            handle.parent     = this.root;
            handle.position.y = +0.6;
            handle.position.z = +0.4;

            this.cameraOffset  = new BABYLON.Vector3(0, 0.8, 0);
            this.speedPosition = new BABYLON.Vector3();
            this.speedRotation = new BABYLON.Vector3();



        }

        setSpeed(position,rotation) {
            if(position) this.speedPosition.copyFrom(position);
            if(rotation) this.speedRotation.copyFrom(rotation);
        }


        setAcceleratoin(position,rotation) {
            if(position) this.speedPosition.addInPlace(position);
            if(rotation) this.speedRotation.addInPlace(rotation);
        }


        stop(dSec) {
            var factor = 1 - dSec*1;
            this.speedPosition.scaleInPlace(factor);
            this.speedRotation.scaleInPlace(factor);

            if(this.speedPosition.length + this.speedRotation.length < 0.01) {
                this.speedPosition = BABYLON.Vector3.Zero();
                this.speedRotation = BABYLON.Vector3.Zero();
                return false;
            }
            else return true;
        }


        resetPositionAndRotation() {
            this.speedPosition = BABYLON.Vector3.Zero();
            this.speedRotation = BABYLON.Vector3.Zero();
            this.root.position           = BABYLON.Vector3.Zero()
            this.root.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, 0.00001/*Why is 0 so od in Babslon???*/, 0);
        }

        // move is part of the controls but is done direct by the bike mash
        animate(){


            this.root.position.addInPlace(this.speedPosition);

            this.root.rotate(BABYLON.Axis.Y, this.speedRotation.y, BABYLON.Space.LOCAL);
            this.root.rotate(BABYLON.Axis.X, this.speedRotation.x, BABYLON.Space.LOCAL); // not .WORLD
            this.root.rotate(BABYLON.Axis.Z, this.speedRotation.z, BABYLON.Space.LOCAL);

            // NO!:  https://doc.babylonjs.com/resources/rotation_conventions#euler-angles-to-quaternions
            // thisroot.rotationQuaternion.addInPlace(BABYLON.Quaternion.RotationYawPitchRoll(speedRotation.y, speedRotation.x, speedRotation.z) );

            var matrix = this.root.getWorldMatrix().getRotationMatrix();
            var cameraOffset2 = BABYLON.Vector3.TransformCoordinates(this.cameraOffset, matrix);

            setCamera(  this.root.position.add(cameraOffset2),
                        this.root.rotationQuaternion );
        }

    }


    class Space {

        constructor(scene) {
            this.scene = scene;
        }

        //// "show" the space
        grid(plusMinus,distance,size) {
            var dot = BABYLON.MeshBuilder.CreateBox("", {size: size},  this.scene);
            for(        var z=-plusMinus ; z<+plusMinus ; z++) {
                for(    var y=-plusMinus ; y<+plusMinus ; y++) {
                    for(var x=-plusMinus ; x<+plusMinus ; x++) {
                        var d = dot.clone("");
                        d.position.x = x * distance;
                        d.position.y = y * distance;
                        d.position.z = z * distance;
                    }
                }
            }
        }


        //// mine wall
        mines(x,plusMinus,distance) {
            var dia = 0.4;
            var big = dia*1.7;
            var sml = dia/10.;
            var min0 = BABYLON.MeshBuilder.CreateSphere("mn", {diameter:dia}, this.scene);
            var box1 = BABYLON.MeshBuilder.CreateBox(   "b1", {height:big, width:sml, depth:sml},  this.scene);
            var box2 = BABYLON.MeshBuilder.CreateBox(   "b2", {height:sml, width:big, depth:sml},  this.scene);
            var box3 = BABYLON.MeshBuilder.CreateBox(   "b3", {height:sml, width:sml, depth:big},  this.scene);

            var red = new BABYLON.StandardMaterial("red", this.scene);  red.ambientColor = red.diffuseColor = BABYLON.Color3.Red();
            box1.material =
            box2.material =
            box3.material =
            min0.material = red;
            var mine = BABYLON.Mesh.MergeMeshes([min0,box1,box2,box3]);

            for(    var z=-plusMinus ; z<+plusMinus ; z++) {
                for(var y=-plusMinus ; y<+plusMinus ; y++) {
                    var m = mine.clone("");
                    m.position.x = x;
                    m.position.y = y * distance;
                    m.position.z = z * distance;
                }
            }
            mine.position.z = 100;
        }


        //// set some gates to fly throu
        gates(count,rotation,dist) {
            // show a "tunnel"
            var tor = BABYLON.MeshBuilder.CreateTorus("", {diameter: 4, thickness: 0.05, tessellation: 4}, this.scene);
            tor.rotation.x = rad(45);
            tor.rotation.y = rad(90);
            tor.rotation.z = rad(90);
            tor.position.z = +4;
            //r.scaling    = new BABYLON.Vector3(0.3,0.3,1)
            for(var z=1 ; z<count ; z++) {
                var t = tor.clone("");
                t.position.z = 4+z*dist;
                t.rotation.x += rad(z*rotation);
            }
        }

        skyDome() { // This is so much more easy with BabylonJS
        	// ???  This line causes twice "Error: WebGL warning: uniformBlockBinding: Index 4294967295 invalid."
        	this.sky = new BABYLON.PhotoDome("sky", /*???p*/'./media/sky.jpg', {size: vrHelper.currentVRCamera.maxZ*0.9}, this.scene); //bbb resolution: 64,size: radius*2
        	this.sky.infiniteDistance = true;
            // Error: WebGL warning: uniformBlockBinding: Index 4294967295 invalid.
            this.sky._mesh.visibility = .001; // does not work, why???  https://www.babylonjs-playground.com/#102TBD#55
        	return this.sky;
        }



        animate = function(dSec) {


      }//animate


    }//Space



    class Earth {

        constructor(scene) {
            this.scene = scene;

            // Original Maßstab geht für Erde in der Oculus Quest nicht. Da flackern die Sterne durch die Erde durch
            var eFACT    = 100
            var radius   = 63781378/eFACT // m Meter   Erdradius: 6.378.137m

            var material = new BABYLON.StandardMaterial("EarthMaterial", scene);
            material.diffuseTexture = new BABYLON.Texture('./media/4096_earth.jpg', scene);
            this.sphere  = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter:radius*2}, scene);
            this.sphere.material = material;
            this.sphere.position.x = -(radius + 4*100*1000   /10 ) // 4 * Weltraumgrenze: 100 Kilometern Höhe  100.000m
            this.sphere.rotation.z = rad(180); // Why is the texture upside down ???
            this.sphere.material = material;
            return this
        }


      animate(dSec) {
        this.sphere.rotation.y += 0.00001;
      }


  }//Earth





    ///////////// MAIN /////////////////////////////////

    var seconds  = 0;
    var vrHelper = undefined;
    var bike     = undefined; // local?
    var xwing    = undefined;
    var earth    = undefined;
    var control  = undefined;

    function setCamera(absolutePosition, rotationQuaternion) {
        var camera = vrHelper.currentVRCamera;        // if(vrHelper.isInVRMode)
        camera.position           = absolutePosition;
        camera.rotationQuaternion = rotationQuaternion;
    }




    window.addEventListener('DOMContentLoaded', function() {

        //// INIT
        var canvas = document.getElementById('viewer');
        var engine = new BABYLON.Engine(canvas, true);
        var scene  = new BABYLON.Scene(engine);
        var light  = new BABYLON.HemisphericLight('hemisLight', new BABYLON.Vector3(0,1,  0), scene);

        scene.clearColor = BABYLON.Color3.Black();

        var fNEAR = 2;                      // to show the bike close by
        var fFAR  = 100*1000*1000*1000*1000      // to show the far away earth. Default: 10'000

        vrHelper = scene.createDefaultVRExperience(/*{defaultheight:0.801 NOP! }*/);
        vrHelper.deviceOrientationCamera.minZ   /= fNEAR    // 2d
        vrHelper.deviceOrientationCamera.maxZ   *= fFAR
        vrHelper.vrDeviceOrientationCamera.minZ /= fNEAR    // cardboard
        vrHelper.vrDeviceOrientationCamera.maxZ *= fFAR
        vrHelper.webVRCamera.minZ               /= fNEAR    // Oculus       currentVRCamera
        vrHelper.webVRCamera.maxZ               *= fFAR
    //  vrHelper._defaultHeight = 0.8 // NOP! sitting on a bike

        vrHelper.currentVRCamera.inputs.attached.keyboard.detachControl(); // Works, on-hooks are removed. But still attached :-/
        vrHelper.currentVRCamera.inputs.attached.mouse.detachControl(); //???

        var space = new Space(scene);
//      space.grid(2,8,0.5);

        space.mines(19,10,10)
        space.gates(12, 4,5);
        space.skyDome();

        earth = new Earth();

        loadGlb("xwing_t65",scene,function(glb){
            xwing = glb;
            xwing.rotation.y = rad(90);
            xwing.position.z = -15; // -4
        });

        bike    = new Bike(scene);
        control = new Control(engine, vrHelper);

        //// RENDER CYCLE
        engine.runRenderLoop(function() {
            var dSec = engine._deltaTime / 1000
            seconds += dSec;

            control.animate(dSec);
            bike   .animate(dSec);
            space  .animate(dSec);
            earth  .animate(dSec);

            if(xwing) {
                var s = seconds*10 % (Math.PI*2)
                var d = Math.sin(s) / 500;
                xwing.position.y += d;
            }

            scene.render();
        });


    });// DOMContentLoaded


    </script>

</body>
</html>
