<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="utf-8"/>
    <title>BLOCKS</title>
    <style>
    html, body { overflow:   hidden;    width: 100%;    height: 100%;     margin: 0;    padding: 0;    }
    #viewer    { touch-action: none;    width: 100%;    height: 100%;                            }
    </style>
</head>
<body>

    <canvas id='viewer' />
    <script src="https://cdn.babylonjs.com/babylon.max.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.js'></script>
<!--
-->
    <script type='module'>
    import { HeadMountedDisplay  } from './src/hmd.js';
    import { Space          } from './src/space.js';

    import { rad,grad,setDeadZone,loadGlb,Ramp,Ramp3,getUrlParameter,limit  } from './src/functions.js';
//  import { WebXRPolyfill  } from './lib/webxr-polyfill.module.js.'; // only abowe ok!!! becaus of httpS?
//  const polyfill = new WebXRPolyfill(); // now, navigator.xr should exist. Returns object with .nativeWebXR
    // info: https://github.com/immersive-web/webxr-polyfill

    /**/
    // To see errors on touch devices, activate this Errorhandler producing Ggalert dialogs
    window.onerror = function(msg,url,line){
        alert(msg+'\n'+url+'\nLine: '+line)
        return true
    }
    /**/

    ///////////// MAIN /////////////////////////////////


    var webvrOk = navigator.getVRDisplays!==undefined;
    var webxrOk = navigator.xr!==undefined;
    var web_rOk = webvrOk || webxrOk;
    var httpsOk = window.location.protocol=="https:";

    //nsole.log("polyfill",polyfill,polyfill.nativeWebXR);
    console.log(".getVRDisplays",navigator.getVRDisplays);
    console.log(".xr",navigator.xr);
    if(!httpsOk) console.log("protocol",window.location.protocol);

    if(!httpsOk && window.location.host!="localhost") window.location = "https://"+ window.location.host + window.location.pathname;


    var seconds  = 0;
    var dSecX    = 1/60;

    var pressed  = 0;
    var box = undefined;
    const boxSize = 0.25;
    var lastBox = undefined

    const spec = 0.2  // ein bischen Glanz ist ok
    var specular0 = new BABYLON.Color3(spec,spec,spec); // Das setzt Babylon automatisch mit diffuseColor ?!? Forum!


    function blockToggle(scene,position) {
        var ix = ((position.x/boxSize+0.5)).toFixed(0);
        var iz = ((position.z/boxSize+0.5)).toFixed(0);
        var iy = ((position.y/boxSize+0.5)).toFixed(0);
        var name = "box:"+ix+","+iy+","+iz;
        console.log(name,position);
    //    var existing = scene.getChildMeshes(false, (node) => { return node.name.indexOf(name) !== -1 });

        var found = scene.meshes.filter(function (child, index, array) {
          return child.name == name;
        });
        console.log(found,scene.meshes);
        if(found.length>0) {
            console.log("name -- ",found[0].name);
            scene.removeMesh(found[0]);
        } else {
            var brig = box.clone("");
            brig.material = box.material.clone("");
            brig.position = new BABYLON.Vector3(ix*boxSize-boxSize/2,
                                                iy*boxSize-boxSize/2,
                                                iz*boxSize-boxSize/2);
            brig.name = name;
            lastBox = brig;
            console.log("name ++ ",brig.name);
        }


    }


    window.addEventListener('DOMContentLoaded', async function() {

        //// INIT
        var canvas = document.getElementById('viewer');
        var engine = new BABYLON.Engine(canvas, true);
        var scene  = new BABYLON.Scene (engine);
        var light  = new BABYLON.HemisphericLight('hemisLight', new BABYLON.Vector3(1,0,1), scene);

        scene.clearColor = BABYLON.Color3.Black();
        scene.moveMode   = limit( getUrlParameter("m",1) * 1 ,1, 3);




        var fNEAR = 2;                          // to show the bike close by
        var fFAR  = 10*1000                     // to show the far away earth. Default: 10'000



        // here we add XR support
        const xrHelper = await scene.createDefaultXRExperienceAsync({
        });

        xrHelper.baseExperience.camera.minZ     /= fNEAR
        xrHelper.baseExperience.camera.maxZ     *= fFAR

        scene.hmd = new HeadMountedDisplay(xrHelper.baseExperience.camera,scene);
        scene.hmd.out(["TEST START"],5000);

        var space = new Space(scene);
        space.ground(100, scene.moveMode==1, xrHelper);
        space.skyDome(xrHelper);


        var material = new BABYLON.StandardMaterial("material", scene); material.diffuseColor = BABYLON.Color3.Yellow();  // nicht specularColor oder emissiveColor!   ambientColor=0 ist unwirksam
        material.specularColor = specular0; //new BABYLON.Color3(); // Das setzt Babylon automatisch mit diffuseColor ?!? Forum!
        box = BABYLON.MeshBuilder.CreateBox("box", {size:boxSize, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
        box.material   = material;
        box.position.y = boxSize/2-9; // hide
        box.position.z = 5;


        // GUI +++
        var plane = BABYLON.Mesh.CreatePlane("plane", 1);
        plane.position = new BABYLON.Vector3(0, 1.5, 1.5);
        //plane.parent     = xrHelper.baseExperience.camera;
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(plane);
        var panel = new BABYLON.GUI.StackPanel();
        advancedTexture.addControl(panel);
        var header = new BABYLON.GUI.TextBlock();
        header.text = "Color GUI";
        header.height = "100px";
        header.color = "white";
        header.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        header.fontSize = "120"
        panel.addControl(header);
        var picker = new BABYLON.GUI.ColorPicker();
        picker.value = new BABYLON.Color3(0,0,1)
        picker.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        picker.height = "350px";
        picker.width = "350px";
        picker.onValueChangedObservable.add(function(value) {
            if(lastBox) {
                lastBox.material.diffuseColor.copyFrom(value);
                pressed = 11; // kein neue Block
            }
        });
        panel.addControl(picker);
        // GUI ---



        // WebXR:
        const webXRInput = xrHelper.input; // if using the experience helper, otherwise, an instance of WebXRInput
        webXRInput.onControllerAddedObservable.add((xrController /* WebXRInputSource instance */ ) => {
            // more fun with the new controller, since we are in XR!
            console.log("xrController",xrController)
            xrController.onMotionControllerInitObservable.add((motionController) => {
                // get the motionController, which is similar to but NOT a gamepad: ???
                console.log("motionController",motionController)
                //if(motionController.handness!="right") return;

                // get the main component (decided by the controller's vendor!)
                const mainComponent = xrController.motionController.getMainComponent();
                console.log("mainComponent",mainComponent)
                // or get the trigger component, if present:
                const mainTrigger = xrController.motionController.getComponent(BABYLON.WebXRControllerComponent.TRIGGER);
                mainComponent.onButtonStateChangedObservable.add((component /* WebXRControllerComponent */ ) => {
                    // check for changes:
                    // pressed changed?
                    if (component.changes.pressed) {
                        var p0 = pressed;
                        pressed += component.pressed ? +1 : -1;
                        console.log(motionController.handness,"component.pressed",component.pressed,pressed)

                        if(pressed==2) {
                            pressed = 12;
                            scene.meshes.forEach(function(item, index) {
                                if(item.name.startsWith("box:"))
                                scene.removeMesh(item);
                            } );
                        }
                        if(pressed==0 && !component.pressed) {
                            // var position = xrController.grip.position.clone();
                            blockToggle(scene,xrController.grip.position)
                        }


                        if(pressed==10)
                            pressed = 0;


                        scene.hmd.out([p0,pressed])
                    }
                })

            });
        });





        //// RENDER CYCLE
        engine.runRenderLoop(function() {
            var dSec1 = engine._deltaTime / 1000
            seconds += dSec1;

            // Why is dSec so irregular??? It causes optical odds while rotating
            var fact = 6
            dSecX = ( dSecX*(fact-1)+dSec1 ) / fact;


            scene.render();
        });


    });// DOMContentLoaded


    </script>

</body>
</html>
